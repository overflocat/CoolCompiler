# MP1&MP2实验综述

## mp1.2

由于这一部分是很久之前做完的，以下部分基本是看着写的代码回忆起来的内容，与实际情况可能有出入。

### 实现过程

首先需要确定lexer中有多少预先给定的token，例如各种保留字以及整形数和类名的定义等。这一部分可以查看include中给定的头文件，防止遗漏。

然后对于给定的token，直接返回对应的值就可以；实验的重点主要是在字符串以及注释的处理上。字符串处理需要注意的重点是换行符以及转义符，注释则需要注意嵌套层数。

### 试验中遇到的问题&解决对策

对于保留字，需要注意区分大小写的问题。比如根据cool的定义，true和false的第一个字母必须是小写，但之后的字母大小写均可。这个问题我是在之后测试的时候才发现我的程序与标准程序行为不一致，并进行了修改。

对于注释的处理，需要注意嵌套层数，因为cool的注释是允许嵌套的（说实话我不是很懂这样定义的意义所在）。这里，需要定义一个变量comment_depth来统计当前注释的层数，碰到`（*`就加一，`*）`减一，直到变量被归零才可以退出注释状态。这里存在的一个容易被忽略问题是：lexer是允许多个文件共同处理的，因此如果在comment状态中遇到了EOF，那么需要把注释层数归零，这样在处理下一个文件的时候才不会出现错误。这个问题比较隐蔽，因为一般测试的时候不是很容易想到这个测试点。

对于字符串的处理，主要是要能够清晰地理解转义符的规定。然后，字符串缓冲区的大小是给定的，因此写入字符时需要注意缓冲区的长度，才能让程序和标准程序行为一致。这里我遇到的几个问题是：首先，字符串中遇到NULL之后根据定义仍然需要需要将字符串读完；然后，字符串中若遇到转义换行符，仍然需要将这个换行符写入字符串，这两个问题都比较容易在测试中发现。

另外还需要注意的是换行符的问题。所有的模式中，遇到换行符都要记得去更新行数统计变量；另外，在DashComment（`--`）中末尾不一定是换行符（可能是EOF），因此DashComment只要写成`--.*`就可以了，写成`--.*\n`反而会出错。

## mp1.3

这个实验分为两部分：对正确源码生成AST以及错误处理。

## 实现过程

对于由正确源码生成AST的部分，只需要参考cool语言的manual，上面提供了一个完整的cool语言的文法，只要对着上面实现即可。实验提供的源程序中有一个对class处理的例子，这个例子非常有用，对照着这个例子，按照其思想模仿就可以解决大部分的问题。

对于错误处理的部分，这一部分一开始我并没有找到什么特别好的方法，因为bison的错误处理非常依赖于正确的终结符设置，那么这里就会有两个问题：

1. 终结符漏了的时候怎么办？
2. 举例而言，在expression中，如果出现错误，我们可以设置`ERROR ;`，`ERROR ）`这样合理的错误处理式，但是对于`ERROR )`，在这种情况下`）`会被错误规约式规约为一个错误，那么之前那个正确输入的左括号就不再能够完成正确的匹配。这种情况要怎么处理？

实现简单的错误处理（比如给定要求的错误处理）并不是很难，但是要想把错误处理程序做得比较完美（例如像标准程序一样，对很大部分我能想到的错误，都能从错误中恢复，即使它不能正确识别所有的错误）是十分困难的。我在实验过程中经常在实现某个错误处理之后，对于某一些例子反而会出现死循环或者其它完全与预期行为不相符的情况。最后，我在不修改第一次提交文法的基础上，采取了利用yychar识别一些简单错误的处理方法来完成错误处理。

### 试验中遇到的问题&解决对策

对于生成正确的AST，完成主要任务的过程就像上面提到的那样，直接对照cool语言的文法定义，以及对示例中class例子的模仿就可以解决掉大部分的问题。这里唯一不好下手的是对let结构的处理。首先，如果仅仅根据文法，let结构是有二义性的，但按照说明，let结构需要能够尽可能地延长。举例而言，`let x : Int in 1+1`应该被识别成`let x : Int in (1+1)`，而不是`(let x : Int in 1)+1`。这里，本来应该对规约式设置优先级，但我采取了一种简单的方法，就是设置IN的优先级为最低，这样就可以比较简单地处理掉这个问题，并且没有什么副作用。另外，在实际测试的时候，我还遇到了当赋值表达式为空时，生成的AST中`no_expr()`的行数和标准程序不一致的问题。这里，只需要将规约式写成`OBJECTID ':' TYPEID assign_exp`，然后令`assign_exp`中一条规约规则为空，这样`no_expr()`就可以在let结构处理完之前就完成规约并生成，这样产生的行号就和标准程序一致了（也更具有参考意义）。

对于错误处理，上面提到的两个问题一开始让我不知道应该该怎样下手，甚至想要重写整个文法。最后，我的处理办法是这样的：

1. 对于第一个问题：只有在结构完全正确的情况下，才允许漏掉终结符。否则，程序将不对其行为做任何保证，至少在一个class里是这样。这么做是合理的，因为想要把所有的错误情况都完整地考虑是不现实的。
2. 对于依赖终结符做规约可能遇到的问题，我一开始的想法是直接将错误规约式写成`ERROR`，但是这样会让产生的错误信息完全不具有可读性。最后，发现了主函数中是利用yychar来取回lexer读到的字符的，这个字符也就是LALR(1)文法中向前看的那个字符；那么，我只需要在`ERROR )`的规约式动作中，加上`yychar = ’)‘`，那么`)`就能够被正确地写回，从而保证前面读到的左括号仍然能够被正确地规约。这一部分这么做是比较简单的处理方案，因为我并不想重写第一次提交中已经完成的文法来实现错误处理，并且这么做足够处理大部分可能的错误（只要终结符没有丢）。

## mp2

### 实现过程

这次实现首先是预备练习部分，通过这一部分可以基本上弄清大部分在mp1.2中需要使用的LLVMIR的使用方法。正确地完成这一部分对后面的实验会有很大的帮助。

对于mp2，我的过程基本上是按照实验攻略来完成的。这一部分最大的问题，就是实验一开始的时候不知道如何下手。mp2提供了一整套api，用于从AST中读取对应的信息，并且利用ValuePrinter将LLVMIR打印出来，但是这一部分API的注释信息实在太少，并且没有什么说明文档可供查阅。这里，我的办法是参考`cgen.cc`中现有的一些例子（尽管不多），主要是关于外部函数声明的例子（例如printf等），这样可以初步了解operand和op_type的作用，以及如何使用ValuePrinter。剩下的部分，除了与同学交流外，就是查阅github上现有的例子（例如群里提供的几个）。这次试验最麻烦的部分是不知道如何下手；正确地生成了`@Main_main`和`@main`函数之后，我基本上弄明白了实验所提供API的使用方法，剩下的部分就没有那么困难了，按照实验说明依次完成即可。

### 试验中遇到的问题&解决对策

首先，这次试验中，生成`@Main_main`和`@main`在整个实验的过程中是比较困难的一步，因为刚开始的时候对实验的整体框架并不了解，而且这一步在整个实验过程中相对而言也是比较难的一部分。解决方法如上述；参考标准程序的输出也是很有帮助的。

之后，实现Int，Bool，算数和比较运算，以及method的过程都比较简单。主要的过程就是看一下对应class的定义，这个class中有哪些成员，之后按图索骥即可。

对于let的实现，由于所有的变量在mp2中一定是在栈上分配空间（主函数用到的字符串不算），因此分配变量的过程并不是很难。这里，我首先遇到的第一个问题是，没有赋值表达式的时候，manual中只是说将值设置为default，并没有说明default是什么。这里，我直接将Int的默认值设为0，Bool的默认值设置为false。

另外，这里还有一个问题：let语句执行完之后应该是要对生成的变量做`kill_local()`处理的，但是如果加上静态分析器，并且在没有赋值表达式的情况下变量也会被初始化的情况下，做不做这个操作对产生的结果在mp2中不会有任何影响，这样就容易导致这个问题被忽略掉。

还有一个小问题，对于产生变量中的`op_type`，直接使用`set_id()`去设置类型之后，class内的name成员并不会被更新，这也就导致了打印IR的时候输出值为空（所以说还是不能完全看着函数名字猜用法）。这里还是调用构造函数比较方便一些，例如`op_type i32_type( INT32 )`，就像函数声明部分提供的例子那样。

然后是赋值语句，这里需要注意的是返回的值应该是赋值语句的计算结果，也就是说在实际操作中返回的是`RHS`所对应的`operand`，因为这里`*LHS`其实上是一个指针。

最后是对控制流的实现。这一部分最简单的方法是先用标准程序生成一个简单的例子，然后再去模仿。整个过程并不难，但有一个问题需要注意，就是if返回值的问题。在mp2中，由于要求中明确说可以假设两个分支返回的是相同的值，因此我这里认为返回值的类型一定和else分支中返回值的类型相同，而没有按照manual中的定义（另外，如果两个分支的返回值类型不一致，标准程序会崩溃，不知道是什么原因）。另外，由于这次实现中类型只有两种，所以我的方法是在分支块开始之前给两种类型的变量都各分配一块内存空间，然后在结束的时候再按照else中返回值的类型去取相应的值并返回。这是一种比较简单的实现方案（避免了回填），不过如果还要接着做mp3的话，这么处理显然是不合适的。

## 总结

通过完成整个实验，我对编译器的构成有了大致的了解，看到自己实现的编译器能够最终将源代码编译成可执行的程序，并且成功地运行也是一件很有成就感的事。另外，通过做这三个实验（mp1.2，mp1.3，mp2）让我对整个cool语言编译器的框架有了更深刻的理解，也明白了cool中的一些设计的理由：例如，将let结构设置为nested是非常有好处的，这样不仅明确了变量的作用域范围，而且方便了IR代码的生成（只需要实现对第一个变量的分配，然后调用`body->code( env )`就可以’递归‘地完成整个let结构的生成，而不需要用到循环），这些理解只有完整地完成整个实验才会有体会。当然，整个实验中，由于实验设计者提供了大量现成的API，因而掩盖了一些实现的细节（比如我现在对cool语言AST的结构仍然不是很了解，因为整个AST的生成和读取都没有在实验中涉及），因此做完整个试验后可能仍然会有一些知识上的欠缺。总体而言，通过完成这三个实验，我对编译器的构建流程有了大致的了解，并且基本上拥有了利用工具去构建编译器的能力，在平时使用编译器时遇到的问题也能够更快地解决。除此之外，这几个实验还起到的一个作用就是大大增加了我对c++的理解，尤其是最后一个实验和之前布置的几个阅读任务。

## 参考文献

UIUC的mp1以及mp2说明文档

助教在gitbook上提供的说明信息

*flex and bison*

*cool manual*和*cool tour*

LLVM和clang的官方说明文档

github上的几个仓库：）

等等