##mp2.0预备练习
这次试验主要是通过所给的一些例子，初步熟悉LLVMIR的格式，并且能够根据一些简单的`.c`文件手工编写对应的LLVMIR。
实验的大致过程就是先用clang去生成所给示例对应的LLVMIR，然后观察所给示例的结果，去学习一些基本的LLVMIR指令，并根据这些指令去编写`fib.c`对应的LLVMIR。

手工翻译的过程总体上还是比较顺利的，因为基本上所有涉及的内容在示例中都可以找到相关的例子，而且即使没有也完全可以手工编写C程序让clang去生成对应的LLVMIR，然后按照样例模仿即可（当然完全也可以先把fib.c先翻译一下看看）。因此这里只说明几个需要注意的问题。

首先，可以先去构造程序的CFG，然后再去根据CFG编写IR。不过由于这里是手工编写，所以不必太过在意程序的基本块，因此一些变量可以跨基本块调用，这和程序自动生成的IR会有一些不同，因此手工编写的IR会更简洁。

然后是关于getelementptr的使用。getelementptr用于计算所变量集合（比如数组）中某一个变量的偏移量，例如如下的例子：

```
%index = getelementptr inbounds i8*, i8** %argv, i64 1
```

在这个例子中，第一个参数是数组中第一个元素所对应的指针，第二个元素是数组的基地址所对应的指针，第三个元素是偏移量。这条语句计算以第二个元素为基地址，加上一个第一个元素对应的偏移所获得的地址，然后将结果存到`%index`中。接下来就可以用load指令取元素：

```
%temp1 = load i8*, i8** %index, align 8
```

这样就得到了指向argv[1]的指针，然后就可以使用这个指针去调用atoi函数。

printf的调用也是一个难点，不过有现成的例子可以模仿。，另外要注意库函数的调用要用declare声明。这次试验所用到的其余的指令基本上都很容易弄明白对应的作用。然后使用clang编译出的LLVMIR中带有一些与具体机器相关的，可以去除的信息（比如版本号等），在手工编写的IR中我都没有加，包括`attributes`部分，因为部分的内容也是和具体的编译环境相关的，并且去掉之后也不影响正常运行。

最后，这次实验只碰到了几个小问题：

首先，编译生成的LLVMIR用llvm-as生成的可执行文件必须用lli才能正常运行。由于`fib.c`的主函数带参，所以直接用`llvmas < fib-m.ll | lli`是不能够正常执行的，必须要先用llvm-as编译成`fib-m.bc`，然后再用lli运行的时候才可以带参数。

另外，在编写makefile的时候，我还遇到了一个奇怪的问题，这个问题也让我浪费了一些时间：VSCode默认会把tab替换成指定数目的空格，而在编写makefile的时候，所调用指令前必须有一个tab。我发现问题之后及时地把这个设置项改了过来。



