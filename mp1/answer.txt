(1)Cool中的list和C++中list最主要的不同为：
    1.C++STL中定义的list是一个双向链表，链表中的元素只能为原子类型，且链表中各元素的类型必须一致；
    2.Cool中定义的list比较类似于Lisp中的广义表，但不完全相同，因为Cool中list只有两个元素。这两个
    元素其中一个为指向表头原子元素的指针，另一个为指向表尾的指针，其中表尾必须是与当前list类型相同的
    list。换言之Cool中list中的元素可以为list类型，这让它更接近于广义表的定义。
   以上的区别还导致了其他方面的一些不同，例如C++中list如要进行遍历直接使用指针从头/尾依次访问每个元素
   即可，但在Cool中对list进行遍历必须要通过反复调用hd()和tl()函数的方式，插入元素时同样如此。除此之外
   C++STL中提供了更多的操作，而Cool中只有打印表，访问元素和计算长度三个函数。另外，Cool中list支持迭代
   定义（例如表A的表尾为表B且表B的表尾为表A），这带来了更高的灵活性，但也可能会造成不必要的麻烦。
（2）String table的意义是对源码中每一个单独的词语进行存储并生成一个唯一的Symbol以便于查询和对比。
   String table为词法分析器建立符号表提供了一个可靠的数据结构。

对mp1.3第一次提交的说明：
    在第一次提交里我只实现了输出正确的AST，没有进行错误处理。
    由于syntax定义以及符号优先级的定义在manual中都已经给出，直接对着写就可以完成大部分的任务，并且解决掉绝大部分可能存在的冲突。
    当然，let结构需要注意，这里主要有两个问题：
    1.let的产生式具有二义性，比如说像let xxx in 1 + 1可以理解为(let xxx in 1) + 1，也可以理解成let xxx in (1 + 1)。根据manual来看的话，后一种是正确的方式。
    这个问题会直接导致处理let结构的时候存在移进-规约冲突。我采用的解决方式是声明终结符IN的优先级为最低，这样可以简单地避免这个问题。
    2.let结构产生的时候行号和参考程序不一致，在参考程序里let结构本身返回的是最后一行的行号，但是里面的赋值语句的行号都在赋值语句被定义的位置。而在我的程序中，所产生的行号都是最后一行。
    这个问题我一开始以为是let constructor本身的问题，直到后来听说这个问题和实现有关，我再去看了一下才发现问题原因。
    简单来讲，如果采用在一个表达式中完成所有匹配的方式，例如LET OBJECTID ':' TYPEID ASSIGN expression IN expression这样，那么在这个表达式里所有的expression行号都是let结构的最后一行；
    但是，如果采用LET OBJECTID ':' TYPEID assign_exp IN expression， 再定义assign_exp: ASSIGN expression的话，那么赋值语句对应的表达式就会按照参考程序的那样在定义的位置生成，行号就可以和参考程序保持一致。
    我一开始采用的是前一种写法，之后更换为后一种就解决了问题。后一种写法生成的行号更有意义，并且可以把空表达式和非空表达式的情况写在一起，可以使程序更精简。
    在feature中也有类似的结构，但是由于这里expression只能在产生式末尾出现，因此不会造成这个问题。在feature中我使用的仍然是前一种写法。