#MP1.2 说明文档
##代码说明
从上到下对代码做一个简要的说明。`cool.flex`里已经有一些注释，内容可能有重复。在`cool.flex`里，为了避免混淆，注释内容以`--`开头的都是我写的注释。
###变量定义部分
定义了变量`comment_depth`，用来统计注释的层数。由于cool语言支持嵌套注释，所以必须当注释层数归零时才能退出注释状态。
定义了变量`null_flag`，用来标明是否在字符串中遇到了NULL。
###正规式命名部分
我采用了*flex and bison*中提到的一种代码风格，对大部分正规式都在此处定义了名称，然后在定义部分直接引用，这样可以少写一点注释，并且代码看上去也更整洁。保留字的定义可以在*manual*中查到，也可以在`utilities.cc`中的`cool_token_to_string`中查看，或者是查看`cool-parse.h`。
###正规式定义部分
对于大部分的状态，直接return对应的值即可。注释不需要返回token。除此之外，出错时要利用`yylval.error_msg`返回错误信息；遇到bool类型变量时要给`yylval.boolean`赋对应的值；遇到ID时，除了要利用`add_string`添加对应的字符串之外，还要给`yylval.symbol`返回对应的对象类型。这些操作在UIUC原版的MP1说明文档中都有说明，涉及到flex和bison的合作。
另外此处还定义了两个状态，也利用了flex提供的*start conition*功能来处理注释和字符串。
####注释状态
除了EOF的处理之外，需要注意的就是注释的嵌套层数，在上文中已经有说明。
####字符串状态
按照*manual*中的说明编写即可。这里有几点需要说明：
>1.每次往缓冲区里写入字符的时候都需要注意缓冲区是否已经填满。我采用的方法是直接用指针进行比较；单独定义一个变量来控制也是可行的。在退出字符串状态的时候，需要检测缓冲区的状态，若已满则报错；否则若不含NULL，则生成一个token。
>2.需要注意转义符`\`的使用。`\n`，`\\n`，`\\\n`是三种不相同的状态，第一种代表非转义的换行符（需要报错），第二种代表`\`和`n`两个字符，第三种代表转义的换行符，写代码时要注意区分。
>3.遇到NULL时需要报错，但仍然需要把字符串读完。

另外还需要注意，在以上两种状态中遇到EOF都需要返回INITIAL状态，否则会导致死循环。由于没有使用flex自带的行数统计变量，所以在每一种状态下遇到换行符时都要记得将行数加一。
##注意事项
已知与reference binaries的不同：在遇到字符串中既存在NULL也存在EOF(或者是转义换行符）时，我的程序会报两个错误，示例程序只会报一个。这个我觉得应该不算错误，并且在定义中也没有说明，所以我没有更改我的程序来使它符合标准程序的行为。
另外，标准程序在遇到`”\<<EOF>>`的时候行为不正常，会直接把出错的字符串打印出来。一般来说在字符串模式下，如果是逐字符匹配的话，不会出现这样的问题；推测标准程序编写时可能使用了按行匹配的模式，并且在遇到`\`的时候处理不正确。
##总结
本次实验难度不大，代码量也不是很多，但是需要阅读不少说明文档（UIUC的mp1说明文档，*flex and bison*中的12章，*cool manual*和一部分源码)，而且关键信息散落在各个地方。我是边做边查文档，反而浪费了不少时间，先看完再做可能会更好。
另外，本次实验有一些比较容易犯错的地方，比如转义换行符按照规定仍然需要写入字符串等，所以需要一些时间来编写测试程序和修改代码。字符串中含有NULL的情况需要用二进制编辑器来构造；字符串以及注释中含有EOF的情况要编写两个文件来测试。我写了一个简单的脚本用来测试和用diff对比产生的tokens的不同，这样让测试方便不少。
